<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cs on 杰森猫的电子博客</title>
    <link>/cs/</link>
    <description>Recent content in Cs on 杰森猫的电子博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 25 Aug 2020 17:49:27 +0800</lastBuildDate>
    
	<atom:link href="/cs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>基于 MVC 的一点思考</title>
      <link>/cs/misc/thinking-in-mvc/</link>
      <pubDate>Tue, 25 Aug 2020 17:49:27 +0800</pubDate>
      
      <guid>/cs/misc/thinking-in-mvc/</guid>
      <description>我从接触编程到现在对MVC的经历是从完全不懂、似懂非懂、自认为完全理解、再到完全不懂。最近面试被问到MVC是什么，自己越说越模糊，越说越没自</description>
    </item>
    
    <item>
      <title>Binary Search 二分查找法</title>
      <link>/cs/algorithm/binary-search/</link>
      <pubDate>Tue, 25 Aug 2020 11:24:38 +0800</pubDate>
      
      <guid>/cs/algorithm/binary-search/</guid>
      <description>复杂度 时间 Average: \( O(log2(n)) \) 空间 \( O(1) \) 核心实现 给定已排序好的数组，在数组中查找对应值的下标，每次循环找到子数组中点判断大小。运行时间稳定。 function binarySearch(arr, target) { let low</description>
    </item>
    
    <item>
      <title>开始使用 Maven 构建 Java 工程</title>
      <link>/cs/java/using-maven/</link>
      <pubDate>Wed, 19 Aug 2020 16:43:53 +0800</pubDate>
      
      <guid>/cs/java/using-maven/</guid>
      <description>Repository Maven的仓库分为Local Repository和Remote Repository，一般在执行mvn命令时会从Remote Reposit</description>
    </item>
    
    <item>
      <title>Radix Sort 基数排序</title>
      <link>/cs/algorithm/radix-sort/</link>
      <pubDate>Sat, 15 Aug 2020 08:12:55 +0800</pubDate>
      
      <guid>/cs/algorithm/radix-sort/</guid>
      <description>复杂度 时间 Best: \( \Omega(nk) \), Average: \( \Theta(nk) \), Worst: \( O(nk) \) 空间 \( O(n+k) \) 其实k=10 核心实现 只能应用到数字的排序算法。先按个位数排序，再按十位排序，以此类推，每次排序的</description>
    </item>
    
    <item>
      <title>Bucket Sort 桶排序</title>
      <link>/cs/algorithm/bucket-sort/</link>
      <pubDate>Fri, 14 Aug 2020 18:08:15 +0800</pubDate>
      
      <guid>/cs/algorithm/bucket-sort/</guid>
      <description>复杂度 时间 Best: \( \Omega(n+k) \), Average: \( \Theta(n+k) \), Worst: \( O(n^2) \) 空间 \( O(n) \) 核心实现 bucket sort相比counting sort加了一些处理，规避了range过大的问题，但同样b</description>
    </item>
    
    <item>
      <title>Heap Sort 堆排序</title>
      <link>/cs/algorithm/heap-sort/</link>
      <pubDate>Fri, 14 Aug 2020 17:06:18 +0800</pubDate>
      
      <guid>/cs/algorithm/heap-sort/</guid>
      <description>复杂度 时间 Best: \( \Omega(n*log_2(n)) \), Average: \( \Theta(n*log_2(n)) \), Worst: \( O(n*log_2(n)) \) 空间 \( O(1) \) 核心实现 堆是把一颗二叉树从左到右从上到下依次写在数组里。最大堆中父节点总是大于等于子节点，如果你</description>
    </item>
    
    <item>
      <title>Counting Sort 计数排序</title>
      <link>/cs/algorithm/counting-sort/</link>
      <pubDate>Thu, 13 Aug 2020 13:00:45 +0800</pubDate>
      
      <guid>/cs/algorithm/counting-sort/</guid>
      <description>复杂度 时间 Best: \( \Omega(n+k) \), Average: \( \Theta(n+k) \), Worst: \( O(n+k) \) 空间 \( O(k) \) 核心实现 直接把要比较的数值当内存偏移量来用。 代码 #include &amp;lt;utility&amp;gt;#include &amp;lt;type_traits&amp;gt; namespace algotest { /** * 借助indices临时空间，将v</description>
    </item>
    
    <item>
      <title>Selection Sort 选择排序</title>
      <link>/cs/algorithm/selection-sort/</link>
      <pubDate>Thu, 13 Aug 2020 12:45:39 +0800</pubDate>
      
      <guid>/cs/algorithm/selection-sort/</guid>
      <description>复杂度 时间 Best: \( \Omega(n^2) \), Average: \( \Theta(n^2) \), Worst: \( O(n^2) \) 空间 \( O(1) \) 核心实现 两层循环，找到并记录其中最小的元素位置，最后跟已排序好元素的Next元素做个替换。 代码 #include</description>
    </item>
    
    <item>
      <title>Insertion Sort 插入排序</title>
      <link>/cs/algorithm/insertion-sort/</link>
      <pubDate>Thu, 13 Aug 2020 11:48:59 +0800</pubDate>
      
      <guid>/cs/algorithm/insertion-sort/</guid>
      <description>复杂度 时间 Best: \( \Omega(n) \), Average: \( \Theta(n^2) \), Worst: \( O(n^2) \) 空间 \( O(1) \) 核心实现 从i开始跟i-1对比，如果小于i-1就跟它做个调换，然后继续对比对比调换。 代码 #include &amp;#34;insertion_sort.h&amp;#34; namespace algotest {</description>
    </item>
    
    <item>
      <title>Merge Sort 合并排序</title>
      <link>/cs/algorithm/merge-sort/</link>
      <pubDate>Thu, 13 Aug 2020 11:09:42 +0800</pubDate>
      
      <guid>/cs/algorithm/merge-sort/</guid>
      <description>复杂度 时间 Best: \( \Omega(n*log_2(n)) \), Average: \( \Theta(n*log_2(n)) \), Worst: \( O(n*log_2(n)) \) 空间 \( O(n) \) 核心实现 把一个数组平均分成左右两段，分别排序，最后的结果就是左数组有序，右数组也有序，然后想个办</description>
    </item>
    
    <item>
      <title>Quick Sort 快速排序</title>
      <link>/cs/algorithm/quick-sort/</link>
      <pubDate>Thu, 13 Aug 2020 07:00:24 +0800</pubDate>
      
      <guid>/cs/algorithm/quick-sort/</guid>
      <description>复杂度 时间 Best: \( \Omega(n*log_2(n)) \), Average: \( \Theta(n*log_2(n)) \), Worst: \( O(n^2) \) 空间 \( O(log_2(n)) \) 核心实现 快速排序的核心思想是先给数组做个分区，分区函数会在数组中找个元素pivot，并且保证要把</description>
    </item>
    
    <item>
      <title>Linux 笔记</title>
      <link>/cs/linux/cheat-sheet/</link>
      <pubDate>Wed, 12 Aug 2020 07:59:46 +0800</pubDate>
      
      <guid>/cs/linux/cheat-sheet/</guid>
      <description>命令 pwd：打印当前进程的工作目录 hostname：打印主机名称 exit：退出当前登录的用户 man：跟一个命令名，调出此命令的操作手册，非常</description>
    </item>
    
    <item>
      <title>使用 JSDoc 代替 TypeScript 实现类型检查</title>
      <link>/cs/javascript/use-jsdoc-instead-of-typescript/</link>
      <pubDate>Fri, 31 Jul 2020 11:47:49 +0800</pubDate>
      
      <guid>/cs/javascript/use-jsdoc-instead-of-typescript/</guid>
      <description>概述 TypeScript是个好东西，不过自从使用TypeScript以后带来了以下几个问题： 代码变的更加复杂 需要正确的设置一些非必要却很复杂</description>
    </item>
    
  </channel>
</rss>